import { fileURLToPath } from 'url';
import MindmapNode from '../models/MindmapNode.js';
import Edge from '../models/Edge.js';
import Problem from '../models/Problem.js';
import mongoose from 'mongoose';
import dotenv from 'dotenv';

dotenv.config();

export const createNode = (id, label, x, y, examples = [], w = 200, h = 80, level = 1, color = "#3b82f6", timeComplexity = "", spaceComplexity = "", keyInsight = "") => ({ id, label, x, y, w, h, examples, level, color, timeComplexity, spaceComplexity, keyInsight });

const nodesData = [
  createNode("root", "DSA Master Patterns", 650, 50, ["Master fundamentals first", "Identify pattern families"], 320, 90, 0, "#6366f1"),
  createNode("arrays", "Arrays & Strings", 100, 200, ["Two pointers, sliding window"], 240, 85, 1, "#10b981", "O(n)", "O(1)", "Sequential processing"),
  createNode("hashing", "Hash Tables", 380, 200, ["Fast lookups O(1)"], 240, 85, 1, "#f59e0b", "O(1) avg", "O(n)", "Constant time access"),
  createNode("trees", "Trees & Graphs", 660, 200, ["DFS/BFS traversals"], 240, 85, 1, "#3b82f6", "O(V+E)", "O(V)", "Recursive structure"),
  createNode("dynamic", "Dynamic Programming", 940, 200, ["Optimal substructure"], 240, 85, 1, "#8b5cf6", "O(n²)", "O(n)", "Build solutions bottom-up"),
  createNode("search", "Search & Sort", 1220, 200, ["Binary search variations"], 240, 85, 1, "#ef4444", "O(log n)", "O(1)", "Divide search space"),
  createNode("twoptr", "Two Pointers", 50, 350, ["Find pairs, move inward"], 180, 70, 2, "#059669"),
  createNode("sliding", "Sliding Window", 250, 350, ["Track window, optimize"], 180, 70, 2, "#0891b2"),
  createNode("hashmap", "Hash Map", 450, 350, ["Key-value storage"], 180, 70, 2, "#d97706"),
  createNode("binary", "Binary Search", 650, 350, ["Divide and conquer"], 180, 70, 2, "#7c3aed"),
  createNode("bfs", "BFS", 850, 350, ["Level-order traversal"], 180, 70, 2, "#dc2626"),
  createNode("dfs", "DFS", 1050, 350, ["Depth-first traversal"], 180, 70, 2, "#1d4ed8"),
  createNode("linkedlist", "Linked List", 250, 200, ["Pointers, slow/fast"], 220, 80, 1, "#0ea5a4", "O(n)", "O(1)", "Pointer manipulation"),
  createNode("graphs", "Graphs", 860, 200, ["Nodes + edges, many algorithms"], 260, 90, 1, "#ef8354", "O(V+E)", "O(V)", "Connectivity & traversal"),
  createNode("trie", "Trie (Prefix Tree)", 1040, 200, ["Prefix search, autocomplete"], 220, 80, 1, "#06b6d4"),
  createNode("matrix", "Matrix", 1220, 350, ["2D traversal, DP on grids"], 220, 80, 2, "#8b5cf6"),
  createNode("bit", "Bit Manipulation", 50, 500, ["XOR, shifts, masks"], 180, 70, 3, "#2563eb"),
  createNode("unionfind", "Union-Find", 450, 500, ["Disjoint set, connected components"], 200, 70, 3, "#334155"),
  createNode("segment", "Segment Tree / BIT", 950, 500, ["Range queries, updates"], 220, 70, 3, "#16a34a"),
  createNode("prefix", "Prefix Sum", 350, 650, ["Cumulative sums for ranges"], 180, 60, 4, "#db2777"),
  createNode("topo", "Topological Sort", 1150, 500, ["Order DAG nodes"], 200, 60, 3, "#ef4444"),
  createNode("geometry", "Geometry", 1250, 500, ["Coordinates, convex hull"], 220, 60, 3, "#0ea5a4"),
  createNode("greedy", "Greedy", 150, 500, ["Best choice at each step"], 160, 60, 3, "#ca8a04"),
  createNode("backtrack", "Backtracking", 350, 500, ["Try all possibilities"], 160, 60, 3, "#be123c"),
  createNode("stack", "Stack", 550, 500, ["LIFO operations"], 160, 60, 3, "#7c2d12"),
  createNode("queue", "Queue", 750, 500, ["FIFO operations"], 160, 60, 3, "#0c4a6e"),
  createNode("heap", "Heap (Priority Queue)", 950, 500, ["Efficient min/max"], 200, 60, 3, "#166534"),
];

const edgesData = [
  { from: "root", to: "arrays", type: "parent" }, { from: "root", to: "hashing", type: "parent" },
  { from: "root", to: "trees", type: "parent" }, { from: "root", to: "dynamic", type: "parent" },
  { from: "root", to: "search", type: "parent" }, { from: "arrays", to: "twoptr", type: "child" },
  { from: "arrays", to: "sliding", type: "child" }, { from: "hashing", to: "hashmap", type: "child" },
  { from: "search", to: "binary", type: "child" }, { from: "trees", to: "bfs", type: "child" },
  { from: "trees", to: "dfs", type: "child" }, { from: "bfs", to: "queue", type: "child" },
  { from: "dfs", to: "stack", type: "child" }, { from: "dfs", to: "backtrack", type: "child" },
  { from: "dynamic", to: "greedy", type: "mix" }, { from: "twoptr", to: "sliding", type: "mix" },
  { from: "bfs", to: "dfs", type: "mix" },
  { from: "arrays", to: "linkedlist", type: "sibling" }, { from: "root", to: "linkedlist", type: "parent" },
  { from: "root", to: "graphs", type: "parent" }, { from: "graphs", to: "bfs", type: "child" },
  { from: "graphs", to: "dfs", type: "child" }, { from: "graphs", to: "unionfind", type: "child" },
  { from: "search", to: "matrix", type: "related" }, { from: "root", to: "trie", type: "parent" },
  { from: "root", to: "bit", type: "parent" }, { from: "root", to: "segment", type: "parent" },
  { from: "dynamic", to: "prefix", type: "related" }, { from: "graphs", to: "topo", type: "related" },
  { from: "search", to: "binary", type: "child" }, { from: "matrix", to: "segment", type: "mix" },
];

const rawProblemData = {
    arrays: [
      { name: "1. Two Sum", difficulty: "Easy", description: "Given an array of integers nums and an integer target, return indices of the two numbers that add up to target." },
      { name: "26. Remove Duplicates from Sorted Array", difficulty: "Easy", description: "Remove duplicates from sorted array in-place, return the number of unique elements." },
      { name: "27. Remove Element", difficulty: "Easy", description: "Remove all occurrences of val from nums in-place. Return number of elements after removal." },
      { name: "35. Search Insert Position", difficulty: "Easy", description: "Find index where target would be inserted in sorted array. Must be O(log n) runtime complexity." },
      { name: "53. Maximum Subarray", difficulty: "Medium", description: "Find the contiguous subarray with the largest sum and return its sum. Use Kadane's algorithm." },
      { name: "66. Plus One", difficulty: "Easy", description: "Add one to the integer represented as a digits array. Handle carry propagation." },
      { name: "88. Merge Sorted Array", difficulty: "Easy", description: "Merge two sorted arrays nums1 and nums2 into nums1 in ascending order." },
      { name: "118. Pascal's Triangle", difficulty: "Easy", description: "Generate first numRows of Pascal's triangle where each number is sum of two numbers above." },
      { name: "119. Pascal's Triangle II", difficulty: "Easy", description: "Return rowIndex-th (0-indexed) row of Pascal's triangle. Optimize space complexity." },
      { name: "121. Best Time to Buy and Sell Stock", difficulty: "Easy", description: "Find maximum profit by choosing a day to buy and a later day to sell. Track minimum price." },
      { name: "122. Best Time to Buy and Sell Stock II", difficulty: "Medium", description: "Maximum profit by buying/selling multiple times. Can't engage in multiple transactions simultaneously." },
      { name: "136. Single Number", difficulty: "Easy", description: "Find single element that appears once while others appear twice. Use XOR for O(1) space." },
      { name: "169. Majority Element", difficulty: "Easy", description: "Find element appearing more than n/2 times. Boyer-Moore voting algorithm gives O(1) space." },
      { name: "217. Contains Duplicate", difficulty: "Easy", description: "Return true if any value appears at least twice in the array. Use HashSet for O(n) time." },
      { name: "219. Contains Duplicate II", difficulty: "Easy", description: "Check if array has duplicates within distance k. Use sliding window with HashSet." },
      { name: "268. Missing Number", difficulty: "Easy", description: "Find missing number in range [0,n] from array of n numbers. Use XOR or sum formula." },
      { name: "283. Move Zeroes", difficulty: "Easy", description: "Move all zeros to end while maintaining relative order of non-zero elements." },
      { name: "414. Third Maximum Number", difficulty: "Easy", description: "Find third distinct maximum number in array. If doesn't exist, return maximum." },
      { name: "448. Find Disappeared Numbers", difficulty: "Easy", description: "Find numbers in range [1,n] missing from array of n integers. Mark visited indices." },
      { name: "485. Max Consecutive Ones", difficulty: "Easy", description: "Return maximum number of consecutive 1's in binary array. Track current and max count." },
      { name: "15. 3Sum", difficulty: "Medium", description: "Find all unique triplets that sum to zero. Sort array and use two pointers technique." },
      { name: "11. Container With Most Water", difficulty: "Medium", description: "Find two lines that together with x-axis forms container holding most water." },
      { name: "238. Product Except Self", difficulty: "Medium", description: "Return array where each element is product of all numbers except itself. No division." },
      { name: "42. Trapping Rain Water", difficulty: "Hard", description: "Calculate how much water can be trapped between bars. Track left/right max heights." },
      { name: "4. Median of Two Sorted Arrays", difficulty: "Hard", description: "Find median of two sorted arrays. Should be O(log(m+n)) complexity." }
    ],
    hashing: [ { name: "1. Two Sum", difficulty: "Easy" }, { name: "217. Contains Duplicate", difficulty: "Easy" }, { name: "242. Valid Anagram", difficulty: "Easy" }, { name: "49. Group Anagrams", difficulty: "Medium" }, { name: "128. Longest Consecutive Sequence", difficulty: "Medium" }, { name: "387. First Unique Character in a String", difficulty: "Easy" }, { name: "3. Longest Substring Without Repeating Characters", difficulty: "Medium" }, { name: "36. Valid Sudoku", difficulty: "Medium" }, { name: "202. Happy Number", difficulty: "Easy" }, { name: "290. Word Pattern", difficulty: "Easy" }, { name: "349. Intersection of Two Arrays", difficulty: "Easy" }, { name: "350. Intersection of Two Arrays II", difficulty: "Easy" }, { name: "599. Minimum Index Sum of Two Lists", difficulty: "Easy" }, { name: "771. Jewels and Stones", difficulty: "Easy" }, { name: "13. Roman to Integer", difficulty: "Easy" }, { name: "454. 4Sum II", difficulty: "Medium" }, { name: "380. Insert Delete GetRandom O(1)", difficulty: "Medium" }, { name: "447. Number of Boomerangs", difficulty: "Medium" }],
    hashmap: [ { name: "1. Two Sum", difficulty: "Easy" }, { name: "217. Contains Duplicate", difficulty: "Easy" }, { name: "242. Valid Anagram", difficulty: "Easy" }, { name: "383. Ransom Note", difficulty: "Easy"}, { name: "205. Isomorphic Strings", difficulty: "Easy"}, { name: "49. Group Anagrams", difficulty: "Medium" }, { name: "128. Longest Consecutive Sequence", difficulty: "Medium" }, { name: "387. First Unique Character in a String", difficulty: "Easy" }, { name: "3. Longest Substring Without Repeating Characters", difficulty: "Medium" }, { name: "36. Valid Sudoku", difficulty: "Medium" }, { name: "454. 4Sum II", difficulty: "Medium" }, { name: "380. Insert Delete GetRandom O(1)", difficulty: "Medium" } ],
    trees: [
      { name: "94. Binary Tree Inorder Traversal", difficulty: "Easy", description: "Implement inorder traversal of binary tree (left->root->right). Try iterative and recursive." },
      { name: "100. Same Tree", difficulty: "Easy", description: "Check if two binary trees are identical in structure and node values. Use recursion." },
      { name: "101. Symmetric Tree", difficulty: "Easy", description: "Check if binary tree is a mirror of itself (symmetric around center). Compare subtrees." },
      { name: "104. Maximum Depth of Binary Tree", difficulty: "Easy", description: "Find height/maximum depth from root to deepest leaf node. Use DFS or BFS." },
      { name: "108. Convert Sorted Array to BST", difficulty: "Easy", description: "Convert sorted array to height-balanced BST. Use binary search approach." },
      { name: "110. Balanced Binary Tree", difficulty: "Easy", description: "Check if binary tree is height-balanced (left/right subtrees differ by at most 1)." },
      { name: "111. Minimum Depth of Binary Tree", difficulty: "Easy", description: "Find shortest path from root to leaf. Remember to check null children." },
      { name: "112. Path Sum", difficulty: "Easy", description: "Check if tree has root-to-leaf path summing to targetSum. Track remaining sum." },
      { name: "144. Binary Tree Preorder Traversal", difficulty: "Easy", description: "Implement preorder traversal (root->left->right). Try Morris Traversal." },
      { name: "145. Binary Tree Postorder Traversal", difficulty: "Easy", description: "Implement postorder traversal (left->right->root). Use stack for iterative." },
      { name: "226. Invert Binary Tree", difficulty: "Easy", description: "Mirror/invert binary tree by swapping left and right children recursively." },
      { name: "257. Binary Tree Paths", difficulty: "Easy", description: "Find all root-to-leaf paths in binary tree. Use backtracking or queue." },
      { name: "572. Subtree of Another Tree", difficulty: "Easy", description: "Check if tree contains another tree as subtree. Use sameTree helper." },
      { name: "102. Binary Tree Level Order Traversal", difficulty: "Medium", description: "Return level-by-level traversal as 2D array. Use queue for BFS." },
      { name: "98. Validate Binary Search Tree", difficulty: "Medium", description: "Verify if tree is valid BST. Track min/max bounds for each subtree." },
      { name: "230. Kth Smallest Element in BST", difficulty: "Medium", description: "Find kth smallest value in BST. Inorder traversal gives sorted order." },
      { name: "199. Binary Tree Right Side View", difficulty: "Medium", description: "Return nodes visible from right side. Use BFS or DFS, track last node per level." },
      { name: "105. Construct Binary Tree from Traversals", difficulty: "Medium", description: "Build tree from preorder and inorder arrays. Use recursion and maps." },
      { name: "124. Binary Tree Maximum Path Sum", difficulty: "Hard", description: "Find max path sum between any two nodes. Track global max in recursion." },
      { name: "297. Serialize and Deserialize Binary Tree", difficulty: "Hard", description: "Design algorithm to serialize/deserialize binary tree to/from string." },
      { name: "236. Lowest Common Ancestor", difficulty: "Medium", description: "Find lowest common ancestor of two nodes in binary tree. Use recursion." },
      { name: "235. Lowest Common Ancestor of BST", difficulty: "Medium", description: "Find LCA in BST. Use BST property to optimize search." },
      { name: "117. Populating Next Right Pointers II", difficulty: "Medium", description: "Connect each node to next node at same level. Use level order traversal." },
      { name: "113. Path Sum II", difficulty: "Medium", description: "Find all root-to-leaf paths that sum to target. Use backtracking." },
      { name: "543. Diameter of Binary Tree", difficulty: "Easy", description: "Find length of longest path between any two nodes. Track max in recursion." }
    ],
    dynamic: [
      { name: "53. Maximum Subarray", difficulty: "Medium", description: "Find contiguous subarray with largest sum. Use Kadane's algorithm with dp array." },
      { name: "70. Climbing Stairs", difficulty: "Easy", description: "Count ways to climb n stairs taking 1 or 2 steps. Use dp[i] = dp[i-1] + dp[i-2]." },
      { name: "121. Best Time to Buy and Sell Stock", difficulty: "Easy", description: "One transaction to maximize profit. Track minimum price seen so far." },
      { name: "198. House Robber", difficulty: "Medium", description: "Maximum money from non-adjacent houses. Use dp[i] = max(dp[i-1], nums[i] + dp[i-2])." },
      { name: "213. House Robber II", difficulty: "Medium", description: "Like House Robber but houses are circular. Solve for nums[0..n-1] and nums[1..n]." },
      { name: "300. Longest Increasing Subsequence", difficulty: "Medium", description: "Find length of longest strictly increasing subsequence. Use binary search or dp." },
      { name: "1143. Longest Common Subsequence", difficulty: "Medium", description: "Find LCS length of two strings. Use 2D dp table for matching chars." },
      { name: "139. Word Break", difficulty: "Medium", description: "Check if string can be segmented into dictionary words. Use dp[i] for substrings." },
      { name: "322. Coin Change", difficulty: "Medium", description: "Minimum coins needed for amount. dp[i] = min(dp[i], 1 + dp[i-coin])." },
      { name: "5. Longest Palindromic Substring", difficulty: "Medium", description: "Find longest palindrome substring. Use dp[i][j] or expand around center." },
      { name: "62. Unique Paths", difficulty: "Medium", description: "Count paths from top-left to bottom-right. Only right and down moves allowed." },
      { name: "63. Unique Paths II", difficulty: "Medium", description: "Like Unique Paths but with obstacles. Check cell before adding paths." },
      { name: "64. Minimum Path Sum", difficulty: "Medium", description: "Find path with minimum sum from top-left to bottom-right. Use 2D dp." },
      { name: "91. Decode Ways", difficulty: "Medium", description: "Count ways to decode string to letters. Check one and two digit numbers." },
      { name: "152. Maximum Product Subarray", difficulty: "Medium", description: "Find subarray with largest product. Track both max and min product." },
      { name: "279. Perfect Squares", difficulty: "Medium", description: "Minimum number of perfect squares that sum to n. Use dp with squares list." },
      { name: "416. Partition Equal Subset Sum", difficulty: "Medium", description: "Can array be split into two equal sum subsets? Use 0/1 knapsack." },
      { name: "518. Coin Change II", difficulty: "Medium", description: "Count number of combinations that make up amount. Order doesn't matter." },
      { name: "72. Edit Distance", difficulty: "Hard", description: "Minimum operations to convert word1 to word2. Use dp for insert/delete/replace." },
      { name: "10. Regular Expression Matching", difficulty: "Hard", description: "Match string to pattern with . and *. Use 2D dp table." },
      { name: "32. Longest Valid Parentheses", difficulty: "Hard", description: "Find length of longest valid parentheses substring. Use dp or stack." },
      { name: "115. Distinct Subsequences", difficulty: "Hard", description: "Count distinct subsequences of s that equal t. Use 2D dp array." },
      { name: "887. Super Egg Drop", difficulty: "Hard", description: "Minimize moves to find critical floor with k eggs. Use dp optimization." },
      { name: "1235. Maximum Profit in Job Scheduling", difficulty: "Hard", description: "Schedule non-overlapping jobs for max profit. Sort by end time." },
      { name: "312. Burst Balloons", difficulty: "Hard", description: "Maximum coins from bursting balloons. Use divide and conquer with dp." }
    ],
    search: [ { name: "704. Binary Search", difficulty: "Easy" }, { name: "35. Search Insert Position", difficulty: "Easy" }, { name: "278. First Bad Version", difficulty: "Easy" }, { name: "374. Guess Number Higher or Lower", difficulty: "Easy" }, { name: "33. Search in Rotated Sorted Array", difficulty: "Medium" }, { name: "153. Find Minimum in Rotated Sorted Array", difficulty: "Medium" }, { name: "74. Search a 2D Matrix", difficulty: "Medium" }, { name: "34. Find First and Last Position of Element in Sorted Array", difficulty: "Medium" }, { name: "162. Find Peak Element", difficulty: "Medium" }, { name: "81. Search in Rotated Sorted Array II", difficulty: "Medium" }, { name: "4. Median of Two Sorted Arrays", difficulty: "Hard" } ],
    binary: [ { name: "704. Binary Search", difficulty: "Easy" }, { name: "35. Search Insert Position", difficulty: "Easy" }, { name: "278. First Bad Version", difficulty: "Easy" }, { name: "374. Guess Number Higher or Lower", difficulty: "Easy" }, { name: "33. Search in Rotated Sorted Array", difficulty: "Medium" }, { name: "153. Find Minimum in Rotated Sorted Array", difficulty: "Medium" }, { name: "74. Search a 2D Matrix", difficulty: "Medium" }, { name: "34. Find First and Last Position of Element in Sorted Array", difficulty: "Medium" }, { name: "162. Find Peak Element", difficulty: "Medium" }, { name: "81. Search in Rotated Sorted Array II", difficulty: "Medium" }, { name: "875. Koko Eating Bananas", difficulty: "Medium"}, { name: "240. Search a 2D Matrix II", difficulty: "Medium"}, { name: "4. Median of Two Sorted Arrays", difficulty: "Hard" } ],
    twoptr: [
      { name: "125. Valid Palindrome", difficulty: "Easy", description: "Check if string is palindrome considering only alphanumeric chars. Use two pointers from ends." },
      { name: "283. Move Zeroes", difficulty: "Easy", description: "Move all zeros to end while maintaining non-zero order. Two pointers: write and read." },
      { name: "344. Reverse String", difficulty: "Easy", description: "Reverse string in-place. Swap chars using two pointers from both ends." },
      { name: "167. Two Sum II - Sorted", difficulty: "Medium", description: "Find two numbers that sum to target in sorted array. Use two pointers approach." },
      { name: "15. 3Sum", difficulty: "Medium", description: "Find triplets that sum to zero. Sort array and use two pointers with outer loop." },
      { name: "11. Container With Most Water", difficulty: "Medium", description: "Find max water container. Move pointer of smaller height inward." },
      { name: "19. Remove Nth From End", difficulty: "Medium", description: "Remove nth node from end of list. Use fast and slow pointers." },
      { name: "876. Middle of Linked List", difficulty: "Easy", description: "Find middle node. Fast pointer moves twice as fast as slow pointer." },
      { name: "141. Linked List Cycle", difficulty: "Easy", description: "Detect cycle in linked list. Floyd's cycle detection with fast/slow pointers." },
      { name: "16. 3Sum Closest", difficulty: "Medium", description: "Find three integers with sum closest to target. Sort and use two pointers." },
      { name: "75. Sort Colors", difficulty: "Medium", description: "Dutch national flag problem. Three pointers for 0s, 1s, and 2s." },
      { name: "42. Trapping Rain Water", difficulty: "Hard", description: "Calculate trapped water. Use two pointers to track max heights from both ends." },
      { name: "18. 4Sum", difficulty: "Medium", description: "Find quadruplets that sum to target. Sort and use nested loops with two pointers." },
      { name: "986. Interval List Intersections", difficulty: "Medium", description: "Find intersections of two interval lists. Use two pointers approach." },
      { name: "977. Squares of Sorted Array", difficulty: "Easy", description: "Square numbers and sort. Two pointers from ends comparing absolute values." },
      { name: "925. Long Pressed Name", difficulty: "Easy", description: "Check if name matches typed chars. Two pointers to match characters." },
      { name: "763. Partition Labels", difficulty: "Medium", description: "Partition string into max parts where letters appear in one part. Track last occurrences." },
      { name: "845. Longest Mountain", difficulty: "Medium", description: "Find longest mountain subarray. Use three pointers for peak finding." },
      { name: "826. Most Profit Assigning Work", difficulty: "Medium", description: "Maximize profit with worker capabilities. Sort and use two pointers." },
      { name: "923. 3Sum With Multiplicity", difficulty: "Medium", description: "Count triplets with sum equal to target. Handle duplicates carefully." },
      { name: "88. Merge Sorted Array", difficulty: "Easy", description: "Merge two sorted arrays in-place. Start from end to avoid overwriting." },
      { name: "80. Remove Duplicates II", difficulty: "Medium", description: "Remove duplicates allowing at most two occurrences. Use two pointers." },
      { name: "287. Find Duplicate Number", difficulty: "Medium", description: "Find duplicate in array using Floyd's algorithm. Similar to cycle detection." },
      { name: "457. Circular Array Loop", difficulty: "Medium", description: "Detect cycles in circular array. Use fast/slow pointer technique." },
      { name: "680. Valid Palindrome II", difficulty: "Easy", description: "Check if palindrome after deleting at most one character. Two pointers with one skip." }
    ],
    sliding: [
      { name: "3. Longest Substring Without Repeating", difficulty: "Medium", description: "Find longest substring without repeating chars. Use sliding window with HashSet." },
      { name: "76. Minimum Window Substring", difficulty: "Hard", description: "Find minimum window containing all chars of t. Use sliding window with counter." },
      { name: "209. Minimum Size Subarray Sum", difficulty: "Medium", description: "Find shortest subarray with sum ≥ target. Slide window and track sum." },
      { name: "239. Sliding Window Maximum", difficulty: "Hard", description: "Find maximum element in each window. Use deque to maintain candidates." },
      { name: "424. Longest Repeating Replacement", difficulty: "Medium", description: "Longest substring with same letter after k changes. Track max frequency." },
      { name: "438. Find All Anagrams", difficulty: "Medium", description: "Find all anagrams of p in s. Use sliding window with character count." },
      { name: "567. Permutation in String", difficulty: "Medium", description: "Check if s2 contains s1's permutation. Fixed size window with char count." },
      { name: "643. Maximum Average Subarray I", difficulty: "Easy", description: "Find subarray of length k with maximum average. Slide fixed size window." },
      { name: "1004. Max Consecutive Ones III", difficulty: "Medium", description: "Longest sequence of 1s after flipping k 0s. Track zeros in window." },
      { name: "340. Substring with K Distinct", difficulty: "Hard", description: "Longest substring with at most k distinct chars. Use sliding window with map." },
      { name: "904. Fruit Into Baskets", difficulty: "Medium", description: "Pick from at most 2 types. Equivalent to at most 2 distinct chars." },
      { name: "992. Subarrays with K Different", difficulty: "Hard", description: "Count subarrays with exactly k different integers. Use two windows." },
      { name: "1248. Count Nice Subarrays", difficulty: "Medium", description: "Count subarrays with exactly k odd numbers. Sliding window technique." },
      { name: "1234. Replace Substring", difficulty: "Medium", description: "Minimum replacements for balanced string. Use sliding window approach." },
      { name: "1208. Get Equal Substrings", difficulty: "Medium", description: "Maximum length of equal cost substring within budget. Slide window." },
      { name: "1052. Grumpy Bookstore", difficulty: "Medium", description: "Maximum satisfied customers using secret technique. Fixed window sum." },
      { name: "995. Minimum Number of K", difficulty: "Hard", description: "Minimum flips to make array valid. Use sliding window of size K." },
      { name: "978. Longest Turbulent Subarray", difficulty: "Medium", description: "Find longest turbulent subarray. Maintain alternating pattern." },
      { name: "930. Binary Subarrays With Sum", difficulty: "Medium", description: "Count subarrays with sum equal to goal. Use sliding window." },
      { name: "1658. Minimum Operations", difficulty: "Medium", description: "Minimum operations to reduce x to zero. Find longest subarray with sum." }
    ],
    bfs: [ { name: "102. Binary Tree Level Order Traversal", difficulty: "Medium" }, { name: "103. Binary Tree Zigzag Level Order Traversal", difficulty: "Medium" }, { name: "107. Binary Tree Level Order Traversal II", difficulty: "Easy" }, { name: "111. Minimum Depth of Binary Tree", difficulty: "Easy" }, { name: "200. Number of Islands", difficulty: "Medium" }, { name: "127. Word Ladder", difficulty: "Hard" }, { name: "994. Rotting Oranges", difficulty: "Medium" }, { name: "542. 01 Matrix", difficulty: "Medium" }, { name: "133. Clone Graph", difficulty: "Medium" } ],
    dfs: [ { name: "104. Maximum Depth of Binary Tree", difficulty: "Easy" }, { name: "112. Path Sum", difficulty: "Easy" }, { name: "113. Path Sum II", difficulty: "Medium" }, { name: "129. Sum Root to Leaf Numbers", difficulty: "Medium" }, { name: "200. Number of Islands", difficulty: "Medium" }, { name: "695. Max Area of Island", difficulty: "Medium" }, { name: "417. Pacific Atlantic Water Flow", difficulty: "Medium" }, { name: "130. Surrounded Regions", difficulty: "Medium" }, { name: "547. Number of Provinces", difficulty: "Medium" }, { name: "399. Evaluate Division", difficulty: "Medium" }, { name: "51. N-Queens", difficulty: "Hard" } ],
    greedy: [ { name: "121. Best Time to Buy and Sell Stock", difficulty: "Easy" }, { name: "122. Best Time to Buy and Sell Stock II", difficulty: "Medium" }, { name: "55. Jump Game", difficulty: "Medium" }, { name: "45. Jump Game II", difficulty: "Medium" }, { name: "134. Gas Station", difficulty: "Medium" }, { name: "53. Maximum Subarray", difficulty: "Medium" }, { name: "881. Boats to Save People", difficulty: "Medium" }, { name: "455. Assign Cookies", difficulty: "Easy" }, { name: "435. Non-overlapping Intervals", difficulty: "Medium" }, { name: "605. Can Place Flowers", difficulty: "Easy" } ],
    backtrack: [
      { name: "17. Letter Combinations", difficulty: "Medium", description: "Generate all possible letter combinations of phone number. Map digits to letters." },
      { name: "22. Generate Parentheses", difficulty: "Medium", description: "Generate all valid parentheses combinations. Track open and close counts." },
      { name: "39. Combination Sum", difficulty: "Medium", description: "Find combinations that sum to target. Can reuse elements. Sort for efficiency." },
      { name: "40. Combination Sum II", difficulty: "Medium", description: "Find unique combinations that sum to target. Can't reuse same element." },
      { name: "46. Permutations", difficulty: "Medium", description: "Generate all possible permutations of distinct integers. Track used numbers." },
      { name: "47. Permutations II", difficulty: "Medium", description: "Generate all unique permutations with duplicates. Use frequency map." },
      { name: "77. Combinations", difficulty: "Medium", description: "Return all possible k combinations of n numbers. Use start index." },
      { name: "78. Subsets", difficulty: "Medium", description: "Generate all possible subsets. Include or exclude each element." },
      { name: "90. Subsets II", difficulty: "Medium", description: "Generate all unique subsets with duplicates. Sort and skip duplicates." },
      { name: "79. Word Search", difficulty: "Medium", description: "Find if word exists in board. Mark visited cells during backtrack." },
      { name: "51. N-Queens", difficulty: "Hard", description: "Place N queens on NxN board. Check diagonal and row conflicts." },
      { name: "37. Sudoku Solver", difficulty: "Hard", description: "Solve Sudoku puzzle. Check row, column and 3x3 box constraints." },
      { name: "131. Palindrome Partitioning", difficulty: "Medium", description: "Find all possible palindrome partitioning of string. Check palindromes." },
      { name: "93. Restore IP Addresses", difficulty: "Medium", description: "Generate all valid IP addresses from string. Check each segment." },
      { name: "216. Combination Sum III", difficulty: "Medium", description: "Find k numbers that sum to n. Use numbers 1-9 exactly once." },
      { name: "254. Factor Combinations", difficulty: "Medium", description: "Find all possible factor combinations. Start from smallest factor." },
      { name: "301. Remove Invalid Parentheses", difficulty: "Hard", description: "Remove minimum parentheses to make valid. Count invalid ones." },
      { name: "306. Additive Number", difficulty: "Medium", description: "Check if string forms additive sequence. Try different first two numbers." },
      { name: "357. Count Numbers with Unique Digits", difficulty: "Medium", description: "Count numbers with unique digits. Permutation with restrictions." },
      { name: "401. Binary Watch", difficulty: "Easy", description: "Show possible times with n LEDs on. Count bits in combinations." }
    ],
    stack: [
      { name: "20. Valid Parentheses", difficulty: "Easy", description: "Check if parentheses string is valid. Push opening, match with closing." },
      { name: "155. Min Stack", difficulty: "Medium", description: "Design stack that supports push, pop, top, getMin operations in O(1)." },
      { name: "739. Daily Temperatures", difficulty: "Medium", description: "Find days until warmer temperature. Use monotonic stack." },
      { name: "150. Evaluate RPN", difficulty: "Medium", description: "Evaluate Reverse Polish Notation expression. Use stack for operands." },
      { name: "22. Generate Parentheses", difficulty: "Medium", description: "Generate all valid parentheses combinations. Use backtracking." },
      { name: "84. Largest Rectangle", difficulty: "Hard", description: "Find largest rectangle in histogram. Use monotonic stack." },
      { name: "496. Next Greater Element I", difficulty: "Easy", description: "Find next greater element in another array. Use stack and map." },
      { name: "503. Next Greater Element II", difficulty: "Medium", description: "Find next greater element in circular array. Use stack twice." },
      { name: "853. Car Fleet", difficulty: "Medium", description: "Count car fleets reaching target. Sort and use monotonic stack." },
      { name: "394. Decode String", difficulty: "Medium", description: "Decode string with numbers and brackets. Use two stacks." },
      { name: "402. Remove K Digits", difficulty: "Medium", description: "Remove k digits to get smallest number. Use monotonic stack." },
      { name: "456. 132 Pattern", difficulty: "Medium", description: "Find 132 pattern in array. Use stack to track potential '2'." },
      { name: "636. Exclusive Time", difficulty: "Medium", description: "Calculate function execution times. Use stack for nested calls." },
      { name: "735. Asteroid Collision", difficulty: "Medium", description: "Simulate asteroid collisions. Use stack to track survivors." },
      { name: "856. Score of Parentheses", difficulty: "Medium", description: "Calculate score of parentheses string. Use stack for depth." },
      { name: "901. Online Stock Span", difficulty: "Medium", description: "Track consecutive days of smaller stock prices. Use monotonic stack." },
      { name: "907. Sum of Subarray Minimums", difficulty: "Medium", description: "Sum of minimum element of all subarrays. Use two monotonic stacks." },
      { name: "921. Minimum Add for Parentheses", difficulty: "Medium", description: "Minimum parentheses to add for validity. Count unmatched." },
      { name: "946. Validate Stack Sequences", difficulty: "Medium", description: "Check if stack operations are possible. Simulate stack operations." },
      { name: "1003. Check Word Validity", difficulty: "Medium", description: "Check if string is valid after substitutions. Use stack to match pattern." }
    ],
    queue: [
      { name: "225. Implement Stack using Queues", difficulty: "Easy", description: "Use queue to implement stack operations. Make push O(n) or pop O(n)." },
      { name: "933. Recent Counter", difficulty: "Easy", description: "Count requests in last 3000ms. Use queue to track time window." },
      { name: "232. Implement Queue using Stacks", difficulty: "Easy", description: "Use two stacks to implement queue. Transfer elements when needed." },
      { name: "622. Design Circular Queue", difficulty: "Medium", description: "Implement fixed-size circular queue. Track front, rear, and size." },
      { name: "641. Design Circular Deque", difficulty: "Medium", description: "Implement double-ended queue. Support both ends operations." },
      { name: "200. Number of Islands", difficulty: "Medium", description: "Count islands in grid. Use BFS with queue to mark connected land." },
      { name: "207. Course Schedule", difficulty: "Medium", description: "Detect cycle in course prerequisites. Use queue for topological sort." },
      { name: "239. Sliding Window Maximum", difficulty: "Hard", description: "Find maximum in sliding window. Use deque to track candidates." },
      { name: "542. 01 Matrix", difficulty: "Medium", description: "Find distance of nearest 0 for each cell. Multi-source BFS with queue." },
      { name: "649. Dota2 Senate", difficulty: "Medium", description: "Simulate voting process. Use two queues for parties." },
      { name: "862. Shortest Subarray Sum", difficulty: "Hard", description: "Find shortest subarray with sum ≥ K. Use deque for monotonic property." },
      { name: "909. Snakes and Ladders", difficulty: "Medium", description: "Find shortest path to last square. BFS with queue for moves." },
      { name: "934. Shortest Bridge", difficulty: "Medium", description: "Find shortest bridge between islands. Multi-source BFS from first island." },
      { name: "950. Reveal Cards", difficulty: "Medium", description: "Reconstruct deck from given order. Use queue to simulate process." },
      { name: "969. Pancake Sorting", difficulty: "Medium", description: "Sort array with pancake flips. Use queue to track operations." },
      { name: "994. Rotting Oranges", difficulty: "Medium", description: "Time for oranges to rot. Multi-source BFS with queue." },
      { name: "1091. Shortest Path Binary Matrix", difficulty: "Medium", description: "Find shortest clear path in grid. BFS with queue for paths." },
      { name: "1188. Design Bounded Queue", difficulty: "Medium", description: "Thread-safe bounded blocking queue. Handle concurrent operations." },
      { name: "1429. First Unique Number", difficulty: "Medium", description: "Track first unique number in stream. Use queue and set." },
      { name: "1823. Find Winner", difficulty: "Medium", description: "Find winner in circular game. Use queue to simulate elimination." }
    ],
    heap: [ { name: "215. Kth Largest Element in an Array", difficulty: "Medium" }, { name: "295. Find Median from Data Stream", difficulty: "Hard" }, { name: "347. Top K Frequent Elements", difficulty: "Medium" }, { name: "973. K Closest Points to Origin", difficulty: "Medium" }, { name: "1046. Last Stone Weight", difficulty: "Easy" }, { name: "703. Kth Largest Element in a Stream", difficulty: "Easy" }, { name: "692. Top K Frequent Words", difficulty: "Medium" }, { name: "23. Merge k Sorted Lists", difficulty: "Hard" }, { name: "378. Kth Smallest Element in a Sorted Matrix", difficulty: "Medium" } ]
  ,
  linkedlist: [ { name: "2. Add Two Numbers", difficulty: "Medium" }, { name: "21. Merge Two Sorted Lists", difficulty: "Easy" }, { name: "19. Remove Nth Node From End of List", difficulty: "Medium" }, { name: "83. Remove Duplicates from Sorted List", difficulty: "Easy" }, { name: "206. Reverse Linked List", difficulty: "Easy" }, { name: "141. Linked List Cycle", difficulty: "Easy" }, { name: "142. Linked List Cycle II", difficulty: "Medium" } ],
  graphs: [
      { name: "133. Clone Graph", difficulty: "Medium", description: "Deep copy a graph. Use HashMap to map original nodes to cloned nodes." },
      { name: "207. Course Schedule", difficulty: "Medium", description: "Detect cycle in directed graph to check if courses can be completed." },
      { name: "210. Course Schedule II", difficulty: "Medium", description: "Return valid course order. Use topological sort with DFS/BFS." },
      { name: "200. Number of Islands", difficulty: "Medium", description: "Count islands in 2D grid. Use DFS/BFS to mark visited land cells." },
      { name: "323. Connected Components", difficulty: "Medium", description: "Count connected components in undirected graph. Use Union-Find or DFS." },
      { name: "785. Is Graph Bipartite?", difficulty: "Medium", description: "Check if graph can be colored with 2 colors. Use BFS/DFS coloring." },
      { name: "310. Minimum Height Trees", difficulty: "Medium", description: "Find roots for min height trees. Remove leaf nodes layer by layer." },
      { name: "743. Network Delay Time", difficulty: "Medium", description: "Find time for signal to reach all nodes. Use Dijkstra's algorithm." },
      { name: "841. Keys and Rooms", difficulty: "Medium", description: "Check if all rooms can be visited. Use DFS to track visited rooms." },
      { name: "547. Number of Provinces", difficulty: "Medium", description: "Count connected cities. Use Union-Find or DFS on adjacency matrix." },
      { name: "797. All Paths From Source to Target", difficulty: "Medium", description: "Find all paths from node 0 to last node in DAG. Use backtracking." },
      { name: "886. Possible Bipartition", difficulty: "Medium", description: "Check if people can be split into two groups without dislikes." },
      { name: "1091. Shortest Path in Binary Matrix", difficulty: "Medium", description: "Find shortest clear path in grid. Use BFS with 8 directions." },
      { name: "947. Most Stones Removed", difficulty: "Medium", description: "Remove max stones on same row/column. Use Union-Find or DFS." },
      { name: "684. Redundant Connection", difficulty: "Medium", description: "Find edge that creates cycle in undirected graph. Use Union-Find." },
      { name: "332. Reconstruct Itinerary", difficulty: "Hard", description: "Find valid itinerary using all tickets. Use DFS with priority queue." },
      { name: "127. Word Ladder", difficulty: "Hard", description: "Find shortest transformation sequence. Use BFS with word pattern matching." },
      { name: "834. Sum of Distances in Tree", difficulty: "Hard", description: "Calculate sum of distances to all other nodes. Use tree DP." },
      { name: "269. Alien Dictionary", difficulty: "Hard", description: "Find order of characters in alien language. Build graph from word order." },
      { name: "1192. Critical Connections", difficulty: "Hard", description: "Find bridges in network. Use Tarjan's algorithm for bridges." },
      { name: "765. Couples Holding Hands", difficulty: "Hard", description: "Min swaps to group couples. Use Union-Find or graph cycles." },
      { name: "864. Shortest Path to Get All Keys", difficulty: "Hard", description: "Find shortest path to collect all keys. Use BFS with state." },
      { name: "787. Cheapest Flights Within K Stops", difficulty: "Medium", description: "Find cheapest price with at most K stops. Use modified Dijkstra/BFS." },
      { name: "959. Regions Cut By Slashes", difficulty: "Medium", description: "Count regions formed by slashes. Convert to grid and use Union-Find." },
      { name: "1202. Smallest String With Swaps", difficulty: "Medium", description: "Find lexicographically smallest string after swaps. Use Union-Find." }
    ],
  trie: [
      { name: "208. Implement Trie", difficulty: "Medium", description: "Implement prefix tree with insert, search and startsWith methods. Use TrieNode class." },
      { name: "211. Design Word Dictionary", difficulty: "Medium", description: "Support adding words and searching with dots as wildcards. Use trie with DFS." },
      { name: "212. Word Search II", difficulty: "Hard", description: "Find all words from dictionary in board. Use trie for efficient prefix checking." },
      { name: "421. Maximum XOR of Two Numbers", difficulty: "Medium", description: "Find maximum XOR of two numbers in array. Build trie with binary bits." },
      { name: "648. Replace Words", difficulty: "Medium", description: "Replace words with their shortest root. Store roots in trie." },
      { name: "677. Map Sum Pairs", difficulty: "Medium", description: "Design map sum with prefix matching. Use trie with values at nodes." },
      { name: "720. Longest Word", difficulty: "Medium", description: "Find longest word built character by character. Use trie and BFS." },
      { name: "745. Prefix and Suffix Search", difficulty: "Hard", description: "Design dictionary with prefix and suffix search. Use two tries or combined trie." },
      { name: "1032. Stream of Characters", difficulty: "Hard", description: "Check if stream ends with dictionary words. Use reverse trie." },
      { name: "1023. Camelcase Matching", difficulty: "Medium", description: "Match pattern maintaining uppercase letters. Use trie for patterns." },
      { name: "676. Implement Magic Dictionary", difficulty: "Medium", description: "Support search with one character different. Use trie with wildcards." },
      { name: "425. Word Squares", difficulty: "Hard", description: "Form word squares using given words. Use trie for prefix matching." },
      { name: "642. Design Search Autocomplete", difficulty: "Hard", description: "Design search with top 3 historical hot sentences. Use trie with priority queue." },
      { name: "472. Concatenated Words", difficulty: "Hard", description: "Find words that can be formed by concatenating other words. Use trie and DFS." },
      { name: "336. Palindrome Pairs", difficulty: "Hard", description: "Find pairs of words that form palindromes. Use trie for reverse matching." },
      { name: "1268. Search Suggestions System", difficulty: "Medium", description: "Suggest products after each character typed. Use trie with sorted insertion." },
      { name: "1233. Remove Sub-Folders", difficulty: "Medium", description: "Remove folders that are subfolders of another folder. Use trie path checking." },
      { name: "820. Short Encoding of Words", difficulty: "Medium", description: "Find shortest reference string encoding all words. Use reverse trie." },
      { name: "1065. Index Pairs of a String", difficulty: "Easy", description: "Find all start-end indices of words in text. Use trie for searching." },
      { name: "1804. Implement Trie II", difficulty: "Medium", description: "Advanced trie with count tracking. Support multiple operations." }
    ],
    matrix: [
      { name: "54. Spiral Matrix", difficulty: "Medium", description: "Return elements in spiral order. Track boundaries and direction." },
      { name: "73. Set Matrix Zeroes", difficulty: "Medium", description: "If element is 0, set row and column to 0. Use first row/col as markers." },
      { name: "289. Game of Life", difficulty: "Medium", description: "Update cell states based on neighbors. Use bit manipulation for in-place." },
      { name: "542. 01 Matrix", difficulty: "Medium", description: "Find distance of nearest 0 for each cell. Use BFS or dynamic programming." },
      { name: "200. Number of Islands", difficulty: "Medium", description: "Count connected 1s as islands. Use DFS to mark visited." },
      { name: "48. Rotate Image", difficulty: "Medium", description: "Rotate matrix 90 degrees clockwise. Transpose then reverse rows." },
      { name: "79. Word Search", difficulty: "Medium", description: "Find if word exists in board. Use backtracking with visited marking." },
      { name: "240. Search 2D Matrix II", difficulty: "Medium", description: "Search in sorted matrix. Start from top-right corner." },
      { name: "329. Longest Increasing Path", difficulty: "Hard", description: "Find longest increasing path. Use DFS with memoization." },
      { name: "417. Pacific Atlantic Water Flow", difficulty: "Medium", description: "Find cells that flow to both oceans. Use two DFS from edges." },
      { name: "498. Diagonal Traverse", difficulty: "Medium", description: "Return elements in diagonal order. Track direction and boundaries." },
      { name: "695. Max Area of Island", difficulty: "Medium", description: "Find largest connected area of 1s. Use DFS with area counting." },
      { name: "733. Flood Fill", difficulty: "Easy", description: "Replace connected same-colored cells. Use DFS or BFS." },
      { name: "766. Toeplitz Matrix", difficulty: "Easy", description: "Check if elements on diagonals are same. Compare with previous row." },
      { name: "867. Transpose Matrix", difficulty: "Easy", description: "Return transpose of matrix. Swap elements across diagonal." },
      { name: "1091. Shortest Path Binary Matrix", difficulty: "Medium", description: "Find shortest clear path in grid. Use BFS with directions." },
      { name: "1254. Number of Closed Islands", difficulty: "Medium", description: "Count islands surrounded by water. DFS from non-border cells." },
      { name: "1293. Shortest Path with Obstacles", difficulty: "Hard", description: "Shortest path allowing k obstacle removals. Use 3D BFS." },
      { name: "1329. Sort Matrix Diagonally", difficulty: "Medium", description: "Sort elements on each diagonal. Group by diagonal index." },
      { name: "1351. Count Negative Numbers", difficulty: "Easy", description: "Count negatives in sorted matrix. Use sorted property efficiently." }
    ],
    bit: [
      { name: "191. Number of 1 Bits", difficulty: "Easy", description: "Count set bits in integer. Use n&(n-1) to clear lowest set bit." },
      { name: "231. Power of Two", difficulty: "Easy", description: "Check if number is power of 2. Use n&(n-1)==0 property." },
      { name: "190. Reverse Bits", difficulty: "Easy", description: "Reverse bits of unsigned integer. Use bit shifting and masking." },
      { name: "136. Single Number", difficulty: "Easy", description: "Find single number in array where others appear twice. Use XOR." },
      { name: "137. Single Number II", difficulty: "Medium", description: "Find number appearing once while others appear thrice. Count bits." },
      { name: "260. Single Number III", difficulty: "Medium", description: "Find two numbers appearing once. Use XOR and rightmost set bit." },
      { name: "268. Missing Number", difficulty: "Easy", description: "Find missing number in range [0,n]. Use XOR with index and value." },
      { name: "338. Counting Bits", difficulty: "Easy", description: "Count bits for each number from 0 to n. Use dynamic programming." },
      { name: "371. Sum of Two Integers", difficulty: "Medium", description: "Add without + operator. Use carry with AND and XOR." },
      { name: "389. Find the Difference", difficulty: "Easy", description: "Find extra letter in shuffled string. Use XOR of all chars." },
      { name: "393. UTF-8 Validation", difficulty: "Medium", description: "Validate UTF-8 encoding. Check leading bits pattern." },
      { name: "397. Integer Replacement", difficulty: "Medium", description: "Min operations to reach 1. Consider bit patterns for odd numbers." },
      { name: "401. Binary Watch", difficulty: "Easy", description: "Show possible times with n LEDs. Count bits in hours and minutes." },
      { name: "421. Maximum XOR", difficulty: "Medium", description: "Find maximum XOR of two numbers. Build trie with bits." },
      { name: "461. Hamming Distance", difficulty: "Easy", description: "Count differing bits between two numbers. Use XOR and count." },
      { name: "476. Number Complement", difficulty: "Easy", description: "Flip all bits in binary representation. Use mask and XOR." },
      { name: "477. Total Hamming Distance", difficulty: "Medium", description: "Sum of Hamming distances for all pairs. Count bits position-wise." },
      { name: "693. Binary Number Alternating", difficulty: "Easy", description: "Check if bits are alternating. Use bit shifting and comparison." },
      { name: "756. Pour Water", difficulty: "Medium", description: "Simulate water flow using bit manipulation. Track water levels." },
      { name: "1009. Complement of Base 10", difficulty: "Easy", description: "Find complement of number. Create mask and XOR." }
    ],
  unionfind: [
      { name: "684. Redundant Connection", difficulty: "Medium", description: "Find edge that creates cycle in graph. Use Union-Find with path compression." },
      { name: "547. Number of Provinces", difficulty: "Medium", description: "Count connected components in graph. Union-Find or DFS both work." },
      { name: "990. Satisfiability of Equations", difficulty: "Medium", description: "Check if equations are satisfiable. Union equals, check not-equals." },
      { name: "128. Longest Consecutive Sequence", difficulty: "Medium", description: "Find longest consecutive elements sequence. Union consecutive numbers." },
      { name: "200. Number of Islands", difficulty: "Medium", description: "Count islands in grid. Can use Union-Find for connected land cells." },
      { name: "305. Number of Islands II", difficulty: "Hard", description: "Handle dynamic island additions. Union-Find with grid coordinates." },
      { name: "323. Connected Components", difficulty: "Medium", description: "Count components in undirected graph. Classic Union-Find application." },
      { name: "399. Evaluate Division", difficulty: "Medium", description: "Evaluate division using equations. Union-Find with weights on edges." },
      { name: "721. Accounts Merge", difficulty: "Medium", description: "Merge user accounts by email. Union-Find to group common emails." },
      { name: "737. Sentence Similarity II", difficulty: "Medium", description: "Check if sentences are similar through chains. Union similar words." },
      { name: "765. Couples Holding Hands", difficulty: "Hard", description: "Min swaps to pair couples. Union-Find to track paired positions." },
      { name: "778. Swim in Rising Water", difficulty: "Hard", description: "Find path with minimum maximum elevation. Union-Find or Dijkstra." },
      { name: "839. Similar String Groups", difficulty: "Hard", description: "Group similar strings. Union strings differing by two positions." },
      { name: "924. Minimize Malware Spread", difficulty: "Hard", description: "Find node to remove to minimize spread. Union-Find for components." },
      { name: "928. Minimize Malware Spread II", difficulty: "Hard", description: "Like 924 but with initial infection set. Track component sizes." },
      { name: "947. Most Stones Removed", difficulty: "Medium", description: "Remove max stones on same row/col. Union stones sharing row/col." },
      { name: "952. Largest Component Size", difficulty: "Hard", description: "Group numbers by common factors. Union numbers sharing factors." },
      { name: "959. Regions Cut By Slashes", difficulty: "Medium", description: "Count regions in grid with slashes. Split cells into 4 triangles." },
      { name: "1101. The Earliest Moment", difficulty: "Medium", description: "Find time when all become friends. Union-Find with timestamps." },
      { name: "1202. Smallest String With Swaps", difficulty: "Medium", description: "Find lexicographically smallest after swaps. Union swappable positions." }
    ],
    segment: [
      { name: "307. Range Sum Query - Mutable", difficulty: "Medium", description: "Support range sum queries with updates. Use segment tree." },
      { name: "308. Range Sum Query 2D - Mutable", difficulty: "Hard", description: "2D version of range sum. Use 2D segment tree or BIT." },
      { name: "315. Count of Smaller After Self", difficulty: "Hard", description: "Count smaller numbers after self. Use segment tree for range count." },
      { name: "327. Count Range Sum", difficulty: "Hard", description: "Count range sums in range. Segment tree for range counting." },
      { name: "493. Reverse Pairs", difficulty: "Hard", description: "Count reverse pairs. Use segment tree or merge sort." },
      { name: "699. Falling Squares", difficulty: "Hard", description: "Track height changes from falling squares. Segment tree for range updates." },
      { name: "715. Range Module", difficulty: "Hard", description: "Track ranges with add/remove/query. Segment tree for range operations." },
      { name: "732. My Calendar III", difficulty: "Hard", description: "Count maximum overlapping events. Segment tree for booking counts." },
      { name: "850. Rectangle Area II", difficulty: "Hard", description: "Calculate area of rectangles union. Segment tree for line sweep." },
      { name: "1157. Online Majority Element", difficulty: "Hard", description: "Find majority element in range. Segment tree with candidate tracking." },
      { name: "1521. Find a Value of Function", difficulty: "Hard", description: "Evaluate function over ranges. Segment tree for range operations." },
      { name: "1526. Minimum Number of Increments", difficulty: "Hard", description: "Min operations to make array equal. Segment tree approach." },
      { name: "1649. Create Sorted Array", difficulty: "Hard", description: "Count numbers smaller/larger in range. Segment tree for counting." },
      { name: "1687. Delivering Boxes", difficulty: "Hard", description: "Optimize box delivery. Segment tree for range optimizations." },
      { name: "218. The Skyline Problem", difficulty: "Hard", description: "Find skyline of buildings. Segment tree for height tracking." },
      { name: "683. K Empty Slots", difficulty: "Hard", description: "Find days with k empty slots between flowers. Segment tree approach." },
      { name: "1505. Minimum Possible Integer", difficulty: "Hard", description: "Find minimum after operations. Segment tree for range updates." },
      { name: "1585. Check String Rearrangement", difficulty: "Hard", description: "Check if string can be rearranged. Segment tree for counting." },
      { name: "1622. Fancy Sequence", difficulty: "Hard", description: "Support multiply and add operations. Segment tree with lazy propagation." },
      { name: "1851. Minimum Interval Query", difficulty: "Hard", description: "Find minimum interval containing each query. Segment tree approach." }
    ],
    prefix: [
      { name: "560. Subarray Sum Equals K", difficulty: "Medium", description: "Count subarrays with sum K. Use prefix sum with hashmap." },
      { name: "303. Range Sum Query", difficulty: "Easy", description: "Find range sums efficiently. Precompute prefix sums." },
      { name: "304. Range Sum Query 2D", difficulty: "Medium", description: "2D version of range sum. Use 2D prefix sum array." },
      { name: "325. Maximum Size Subarray Sum", difficulty: "Medium", description: "Find longest subarray with sum k. Use prefix sum with map." },
      { name: "437. Path Sum III", difficulty: "Medium", description: "Count paths with target sum. Use prefix sum in tree." },
      { name: "523. Continuous Subarray Sum", difficulty: "Medium", description: "Find subarray with sum multiple of k. Use prefix sum mod k." },
      { name: "525. Contiguous Array", difficulty: "Medium", description: "Find longest subarray with equal 0s and 1s. Map sum to index." },
      { name: "528. Random Pick with Weight", difficulty: "Medium", description: "Pick index by weight. Use prefix sum for binary search." },
      { name: "724. Find Pivot Index", difficulty: "Easy", description: "Find index where left sum equals right sum. Use total sum." },
      { name: "862. Shortest Subarray Sum >= K", difficulty: "Hard", description: "Find shortest subarray with sum ≥ K. Use deque." },
      { name: "974. Subarray Sums Divisible by K", difficulty: "Medium", description: "Count subarrays divisible by K. Use prefix sum mod K." },
      { name: "1074. Number of Submatrices", difficulty: "Hard", description: "Count submatrices with target sum. Use 2D prefix sum." },
      { name: "1124. Longest Well-Performing", difficulty: "Medium", description: "Find longest well-performing interval. Use prefix sum." },
      { name: "1248. Count Nice Subarrays", difficulty: "Medium", description: "Count subarrays with k odd numbers. Use prefix sum of odds." },
      { name: "1314. Matrix Block Sum", difficulty: "Medium", description: "Compute block sums in matrix. Use 2D prefix sum." },
      { name: "1371. Find Longest Substring", difficulty: "Medium", description: "Longest substring with even vowels. Track vowel counts." },
      { name: "1423. Maximum Points Cards", difficulty: "Medium", description: "Max score from picking cards. Use sliding window with sums." },
      { name: "1442. Count Triplets XOR", difficulty: "Medium", description: "Count triplets with XOR zero. Use prefix XOR array." },
      { name: "1477. Find Two Non-overlapping", difficulty: "Medium", description: "Find two subarrays with target sum. Use prefix sum and DP." },
      { name: "1524. Number of Sub-arrays", difficulty: "Medium", description: "Count subarrays with odd sum. Use prefix sum parity." }
    ],
    topo: [
      { name: "210. Course Schedule II", difficulty: "Medium", description: "Find valid course ordering. Use Kahn's algorithm or DFS." },
      { name: "269. Alien Dictionary", difficulty: "Hard", description: "Find character order from dictionary. Build graph from adjacent words." },
      { name: "207. Course Schedule", difficulty: "Medium", description: "Detect if courses can be completed. Check for cycles in graph." },
      { name: "310. Minimum Height Trees", difficulty: "Medium", description: "Find tree roots with min height. Remove leaves layer by layer." },
      { name: "329. Longest Increasing Path", difficulty: "Hard", description: "Find longest increasing path in matrix. Use DFS with memoization." },
      { name: "444. Sequence Reconstruction", difficulty: "Medium", description: "Check if sequence can be uniquely reconstructed. Verify order." },
      { name: "802. Find Eventual Safe States", difficulty: "Medium", description: "Find nodes that lead to terminal nodes. Reverse edges approach." },
      { name: "851. Loud and Rich", difficulty: "Medium", description: "Find quietest person among richer. Build graph and do DFS." },
      { name: "1136. Parallel Courses", difficulty: "Medium", description: "Minimum semesters to finish courses. Layer by layer approach." },
      { name: "1203. Sort Items by Groups", difficulty: "Hard", description: "Sort items respecting group and item dependencies. Two-level topo sort." },
      { name: "1462. Course Schedule IV", difficulty: "Medium", description: "Check if course is prerequisite. Build reachability matrix." },
      { name: "1591. Strange Printer II", difficulty: "Hard", description: "Check if grid can be printed. Build color dependency graph." },
      { name: "1632. Rank Transform Matrix", difficulty: "Hard", description: "Transform matrix keeping order. Build graph from rows and cols." },
      { name: "1786. Number of Restricted Paths", difficulty: "Medium", description: "Count paths with decreasing distances. Dijkstra + DFS." },
      { name: "2050. Parallel Courses III", difficulty: "Hard", description: "Minimum time to complete courses. Topo sort with time constraints." },
      { name: "2115. Find All Possible Recipes", difficulty: "Medium", description: "Find makeable recipes from ingredients. Build dependency graph." },
      { name: "2192. All Ancestors DAG", difficulty: "Medium", description: "Find all ancestors in DAG. Use transitive closure." },
      { name: "2204. Distance to Cycle", difficulty: "Hard", description: "Find distance to nearest cycle. Identify SCCs first." },
      { name: "2246. Longest Path With Steps", difficulty: "Hard", description: "Find longest path with conditions. Build DAG and do DFS." },
      { name: "2360. Longest Cycle in Graph", difficulty: "Hard", description: "Find longest cycle in functional graph. Use cycle detection." }
    ],
    geometry: [
      { name: "223. Rectangle Area", difficulty: "Medium", description: "Calculate total area of two rectangles. Handle overlap carefully." },
      { name: "149. Max Points on Line", difficulty: "Hard", description: "Find max points on same line. Use slope to group points." },
      { name: "587. Erect the Fence", difficulty: "Hard", description: "Find convex hull of points. Implement Graham's scan." },
      { name: "391. Perfect Rectangle", difficulty: "Hard", description: "Check if rectangles form perfect rectangle. Check area and corners." },
      { name: "593. Valid Square", difficulty: "Medium", description: "Check if 4 points form square. Verify distances and angles." },
      { name: "892. Surface Area of 3D Shapes", difficulty: "Easy", description: "Calculate surface area of 3D structure. Count visible faces." },
      { name: "963. Minimum Area Rectangle II", difficulty: "Medium", description: "Find smallest area rectangle. Check diagonal intersections." },
      { name: "1030. Matrix Cells in Distance Order", difficulty: "Easy", description: "Sort cells by distance from point. Use Manhattan distance." },
      { name: "1232. Check Straight Line", difficulty: "Easy", description: "Check if points form straight line. Use slope comparison." },
      { name: "1266. Minimum Time Visiting Points", difficulty: "Easy", description: "Find minimum time to visit points. Use Chebyshev distance." },
      { name: "1401. Circle and Rectangle", difficulty: "Medium", description: "Check if circle and rectangle overlap. Test distance to edges." },
      { name: "1453. Maximum Points Line", difficulty: "Hard", description: "Maximum points on line passing through point. Count slopes." },
      { name: "1515. Best Position Service", difficulty: "Hard", description: "Find point minimizing sum of distances. Binary search approach." },
      { name: "1610. Maximum Number Visible", difficulty: "Hard", description: "Count visible points within angle. Use polar angles." },
      { name: "1828. Queries on Points", difficulty: "Medium", description: "Count points in rectangles. Can use sweep line." },
      { name: "1924. Erect the Fence II", difficulty: "Hard", description: "Find smallest enclosing circle. Implement Welzl's algorithm." },
      { name: "1943. Describe the Painting", difficulty: "Medium", description: "Describe painted segments. Use line sweep technique." },
      { name: "2013. Detect Squares", difficulty: "Medium", description: "Count squares with point. Use diagonal properties." },
      { name: "2280. Minimum Lines", difficulty: "Medium", description: "Minimum lines to represent points. Check slope changes." },
      { name: "2249. Count Lattice Points", difficulty: "Medium", description: "Count points inside circles. Check distance to center." }
    ]
};



const problemsData = Object.entries(rawProblemData).flatMap(([nodeId, problemList]) => 
  problemList.map(problem => ({
    nodeId: nodeId,
    name: problem.name,
    title: problem.name,
    difficulty: problem.difficulty,
    description: problem.description || '',
    link: problem.link || ''
  }))
);

const MONGO_URI = process.env.MONGO_URI;

// Export all the data for reuse
export { edgesData, problemsData, rawProblemData };

const seedDatabase = async () => {
  try {
    await mongoose.connect(MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true });
    console.log('MongoDB connected for seeding');

    await MindmapNode.deleteMany({});
    await Edge.deleteMany({});
    await Problem.deleteMany({});

    const insertedNodes = await MindmapNode.insertMany(nodesData);
    console.log('Nodes seeded:', insertedNodes.length);

    const insertedEdges = await Edge.insertMany(edgesData);
    console.log('Edges seeded:', insertedEdges.length);

    const insertedProblems = await Problem.insertMany(problemsData);
    console.log('Problems seeded:', insertedProblems.length);

  } catch (error) {
    console.error('Error seeding database:', error);
  } finally {
    mongoose.connection.close();
    console.log('MongoDB connection closed');
  }
};

// Only run seeding if this file is being run directly
if (process.argv[1] === fileURLToPath(import.meta.url)) {
  seedDatabase();
}